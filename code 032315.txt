#------Evaluation Routine

# Assume that age is the only continuous variable and needs to be bucketed
# The vector age_banding has the age banding for the risk adjuster
# Assume that there is only one age banding for the risk adjuster
# Assume members is the data frame of member records
#Create a column of categorical ages by range lookup
age_category <- findInterval(members$age, age_banding)
#Append to the copy of the 
members$categorical_age <- categorical_age
#Assume there are two types of scoring - table-based and expression-based
#table-based is for the large lookups.  expression-based is for ad hoc 
#We first consider expression-based:
#Evaluate member-level expression to see if the lookup table should be chosen
#Five slots:
#1. Table Expression using only member-level variables.  This expression has to be true for the grouper and scoring table to be evaluated for the member.  Evaluated once per member.
# example  quote("gender==2")
#2. Grouper Table - dataframe with claim or member-level variables along with the assigned grouper.  It's assumed that the grouper column is called grouper.  Evaluated once per member claim.
# There can be any number of specification variables other than the grouper column, as long as they appear in either the member or claim data frames
# There can only be one grouper column and the other column names need to correspond to names of columns in the member or claims data frames
# example maleagegenderfactors <- data.frame(rbind(c(0,"M0-34"),c(1,"M35-39")),names=c("age_category","grouper"))
#3. Evaluate the expression-only based grouper assignments

#interaction terms can contain table-based and expression-based groupers
#Must be grouper names separated by plus signs
"HCC3+HCC4"

#4. hierarchies vector - contains both grouper and interaction heirarchy statements
Grouper Hierarchies - vector of expressions for grouper hierarchies.  Evaluated after all grouper assignments for the grouper table 
Vector of hierarchy terms c(quote("HCC10>HCC3>HCC4"),quote("HCC3>HCC14>HCC20"))
-add heirarchy
-remove heirarchy
-show heirarchies

#5. Scoring Table - dataframe of groupers along with 
# No member-level expression since groupers have already been assigned
A data.frame with grouper name and score.

#sum up scores
#Normalization factor

#Load Risk Adjuster
#Medicare 2014 PY CMS-HCC community enrolled
age_bands <- c(0,35,45,55,60,65,70,75,80,85,90,95)
female_age_scores <- c(0.197,0.205,0.263,0.326,0.392,0.288,0.348,0.437,0.539,0.677,0.815,0.840)
male_age_scores <- c(0.121,0.124,0.181,0.269,0.311,0.288,0.356,0.442,0.543,0.683,0.848,1.028)
#disabled indicator variable
disabled <- age<65 & OASI >0
#originally disabled indicator variable
originally_disabled <- age >= 65 & OASI %in% c(1,3)
Medicaid_Female_Aged <- medicaid & gender==2 & disabled==0

#Grouper definition:
#(Object name)
#Grouper Description
#Expression - string with member or claims variables
#dx_list (optional, for easy diasnosis loading) - If list is entered, then the member qualifies for the grouper if any of the diagnoses are included AND the expression is true

#Compile Grouper Hierarchies table before 
#Vector of grouper objects
#Converts expressions like HCC1>HCC2>HCC3 to a compiled table for performance, table created before evaluation
#Evaluation tests whether the first two columns of the compiled table are true, and if so, sets the second column value to FALSE
#e.g. Higher | Lower
#	HCC1 | HCC2
#	HCC1 | HCC3
#	HCC2 | HCC3

#Interaction is a combination of Groupers
#Description
#Vector of grouper objects with the assumption that all have to be true in order for the combination to be true

#Interaction Hierarchies table, similar to grouer hierarchies table but evaluated at a different time
#e.g. INT1>INT2>INT3

# Define risk adjuster class:
# Description
# Vector of groupers
# Vector of grouperHierarchies
# Vector of grouperScores
# Vector of interactions 
# Vector of interactionHierarchies
# Vector of interactionScores
# Normalization Factor

#Performance advantage by using one-to-one mapping for icd9 to dx

#load routine to load standard risk adjusters
#Helper function to add age_band to 

#Evaluation routine creates boolean vector the same length as the groupers vector
#Loops through the groupers calling the test grouper routine
#

riskadjuster <- setClass("riskadjuster",
	slots=c(age_banding="numeric"),
	prototype=list(age_banding=c(0,100)),
	validity=function(object){
		return(TRUE)
	}
	)
setGeneric(function="set_age_banding",
	definition=function(riskadjuster,new_age_banding){
		standardGeneric(riskadjuster,new_age_banding)
	}
setMethod(f="set_age_banding",
	signature=c("riskadjuster","numeric"),
	definition=function(riskadjuster,new_age_banding) {
		riskadjuster@age_banding <- new_age_banding
		return(riskadjuster)
	}
	)

#Class hierarchy:
# Base class is expression (includes member and claim level variables), use the same variables as column names in those data frames
# Derived classes are table-based and value-based assignment (single and multiple assignment)

#Condition Category
#Functions on condition categories - group, interaction, hierarchy
#Vectorized on inputs (cross-product)


#HHS-HCC
#Independently verify SAS algorithm
#Lazy error evaluation
SEVERE_V3 <- group(2,42,120,122,125,126,127,156)
INT_GROUP_H <- interaction(rep(SEVERE_V3,9),c(6,8,9,10,115,135,145,G06,G08))
INT_GROUP_M <- interaction(rep(SEVERE_V3,7),c(35,38,153,154,163,253))
